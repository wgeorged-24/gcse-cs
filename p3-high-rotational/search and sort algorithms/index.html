<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search & Sort Algorithms | GCSE Computer Science</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --bg-card-hover: #1a1a25;
            --accent-cyan: #00d4ff;
            --accent-magenta: #ff006e;
            --accent-yellow: #ffd60a;
            --accent-green: #00ff88;
            --accent-orange: #ff9500;
            --accent-purple: #a855f7;
            --text-primary: #ffffff;
            --text-secondary: #8888aa;
            --text-muted: #555566;
            --border-subtle: #2a2a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.7;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
        }

        .exam-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-magenta));
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 6px 14px;
            border-radius: 20px;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 2.4rem;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 300;
        }

        .progress-container {
            margin-top: 30px;
        }

        .progress-bar {
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--border-subtle);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .progress-dot.active {
            background: var(--accent-cyan);
            box-shadow: 0 0 12px var(--accent-cyan);
            transform: scale(1.2);
        }

        .progress-dot.completed {
            background: var(--accent-green);
        }

        .progress-label {
            margin-top: 12px;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 28px 32px;
            margin-bottom: 20px;
        }

        .learning-objective {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.08), rgba(0, 212, 255, 0.02));
            border-left: 3px solid var(--accent-cyan);
            padding: 16px 20px;
            margin-bottom: 24px;
            border-radius: 0 12px 12px 0;
        }

        .learning-objective-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-cyan);
            margin-bottom: 6px;
        }

        .learning-objective p, .learning-objective ul {
            color: var(--text-primary);
            margin: 0;
        }

        .learning-objective ul {
            margin-top: 10px;
            padding-left: 20px;
        }

        .learning-objective li {
            margin-bottom: 6px;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 16px;
            color: var(--accent-cyan);
        }

        h3 {
            font-size: 1.15rem;
            margin-bottom: 14px;
            color: var(--text-primary);
        }

        p {
            color: var(--text-secondary);
            margin-bottom: 14px;
        }

        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .highlight-cyan {
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .highlight-magenta {
            color: var(--accent-magenta);
            font-weight: 600;
        }

        .highlight-green {
            color: var(--accent-green);
            font-weight: 600;
        }

        .highlight-purple {
            color: var(--accent-purple);
            font-weight: 600;
        }

        /* Key Term Definition */
        .key-term {
            background: linear-gradient(135deg, rgba(255, 214, 10, 0.1), rgba(255, 149, 0, 0.05));
            border: 1px solid rgba(255, 214, 10, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
        }

        .key-term-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .key-term-badge {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .key-term-word {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-yellow);
        }

        .key-term p {
            color: var(--text-primary);
            margin: 0;
        }

        /* Think About It Box */
        .think-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(168, 85, 247, 0.03));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
        }

        .think-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: var(--accent-purple);
            font-weight: 600;
        }

        .think-box p, .think-box ul {
            color: var(--text-primary);
            margin: 0;
        }

        /* Connect Box */
        .connect-box {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.08), rgba(0, 255, 136, 0.02));
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
        }

        .connect-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: var(--accent-green);
            font-weight: 600;
        }

        .connect-box p {
            color: var(--text-primary);
            margin: 0;
        }

        /* Warning/Misconception Box */
        .warning-box {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.1), rgba(255, 0, 110, 0.03));
            border: 1px solid rgba(255, 0, 110, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
        }

        .warning-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: var(--accent-magenta);
            font-weight: 600;
        }

        .warning-box p {
            color: var(--text-primary);
            margin: 0;
        }

        /* Example Box */
        .example-box {
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
        }

        .example-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .example-badge {
            background: var(--accent-cyan);
            color: var(--bg-dark);
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .example-title {
            font-weight: 600;
            color: var(--accent-cyan);
        }

        /* Interactive Array Display */
        .array-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin: 20px 0;
            min-height: 60px;
        }

        .array-item {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-card);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .array-item.highlight-search {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.2);
            transform: scale(1.1);
        }

        .array-item.found {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.15);
        }

        .array-item.eliminated {
            opacity: 0.3;
            transform: scale(0.9);
        }

        .array-item.comparing {
            border-color: var(--accent-yellow);
            background: rgba(255, 214, 10, 0.2);
        }

        .array-item.sorted {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.15);
        }

        .array-item.merging {
            border-color: var(--accent-purple);
            background: rgba(168, 85, 247, 0.2);
        }

        .array-index {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
            text-align: center;
        }

        .array-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Step indicator */
        .step-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 16px 0;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 8px;
        }

        .step-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .step-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
            font-weight: 600;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
        }

        .control-btn {
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn.primary {
            background: var(--accent-cyan);
            color: var(--bg-dark);
        }

        .control-btn.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .control-btn.secondary {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            color: var(--text-secondary);
        }

        .control-btn.secondary:hover:not(:disabled) {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Explanation panel */
        .explanation-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 16px 0;
            min-height: 80px;
        }

        .explanation-panel p {
            color: var(--text-primary);
            margin: 0;
        }

        /* Code display */
        .code-block {
            background: #1a1a2e;
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }

        .code-block pre {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            margin: 0;
            line-height: 1.6;
        }

        .code-keyword {
            color: var(--accent-magenta);
        }

        .code-function {
            color: var(--accent-cyan);
        }

        .code-string {
            color: var(--accent-green);
        }

        .code-comment {
            color: var(--text-muted);
        }

        .code-number {
            color: var(--accent-orange);
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 14px 16px;
            text-align: left;
            border: 1px solid var(--border-subtle);
        }

        .comparison-table th {
            background: var(--bg-card);
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .comparison-table td {
            color: var(--text-primary);
        }

        .comparison-table tr:nth-child(even) td {
            background: rgba(0, 0, 0, 0.2);
        }

        /* Quiz Options */
        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-btn {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            padding: 14px 20px;
            border: 2px solid var(--border-subtle);
            border-radius: 10px;
            background: var(--bg-dark);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .option-btn:hover:not(:disabled) {
            border-color: var(--accent-cyan);
            transform: translateX(4px);
        }

        .option-btn.correct {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.15);
        }

        .option-btn.incorrect {
            border-color: var(--accent-magenta);
            background: rgba(255, 0, 110, 0.15);
        }

        .option-btn:disabled {
            cursor: not-allowed;
            opacity: 0.85;
        }

        /* Feedback */
        .feedback {
            padding: 14px 16px;
            border-radius: 8px;
            margin-top: 14px;
            display: none;
            font-size: 0.95rem;
        }

        .feedback.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .feedback.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }

        .feedback.error {
            background: rgba(255, 0, 110, 0.1);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .feedback.hint {
            background: rgba(255, 214, 10, 0.1);
            border: 1px solid var(--accent-yellow);
            color: var(--accent-yellow);
        }

        /* Notes Summary */
        .notes-summary {
            background: linear-gradient(135deg, rgba(255, 149, 0, 0.08), rgba(255, 214, 10, 0.05));
            border: 1px solid rgba(255, 149, 0, 0.3);
            border-radius: 12px;
            padding: 20px 24px;
            margin-top: 24px;
        }

        .notes-summary-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
            color: var(--accent-orange);
            font-weight: 600;
        }

        .notes-summary h4 {
            color: var(--accent-yellow);
            font-size: 1rem;
            margin: 16px 0 8px 0;
        }

        .notes-summary h4:first-of-type {
            margin-top: 0;
        }

        .notes-summary p, .notes-summary ul {
            color: var(--text-primary);
            margin: 0 0 8px 0;
        }

        .notes-summary ul {
            padding-left: 20px;
        }

        .notes-summary li {
            margin-bottom: 4px;
        }

        /* Navigation */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-subtle);
        }

        .nav-btn {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-btn.prev {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            color: var(--text-secondary);
        }

        .nav-btn.prev:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .nav-btn.next {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            color: white;
        }

        .nav-btn.next:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Merge sort specific */
        .merge-level {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .merge-group {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
        }

        .merge-group.active {
            border-color: var(--accent-purple);
            background: rgba(168, 85, 247, 0.1);
        }

        .merge-item {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        /* Input styling */
        .input-group {
            display: flex;
            gap: 12px;
            align-items: center;
            margin: 16px 0;
        }

        .input-field {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            padding: 12px 16px;
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            background: var(--bg-dark);
            color: var(--text-primary);
            width: 120px;
            text-align: center;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 20px 16px;
            }

            h1 {
                font-size: 1.8rem;
            }

            .card {
                padding: 20px;
            }

            .array-item {
                width: 42px;
                height: 42px;
                font-size: 0.95rem;
            }

            .nav-buttons {
                flex-direction: column;
                gap: 12px;
            }

            .nav-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="exam-badge">OCR GCSE Computer Science</div>
            <h1>Search & Sort Algorithms</h1>
            <p class="subtitle">Binary Search ‚Ä¢ Merge Sort ‚Ä¢ Algorithm Efficiency</p>
            
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
                <p class="progress-label" id="progressLabel">Section 1 of 10</p>
            </div>
        </header>

        <main id="content">
            <!-- Section 1: Welcome -->
            <section id="section-1" class="active">
                <div class="card">
                    <h2>üéØ What You'll Master</h2>
                    
                    <div class="learning-objective">
                        <div class="learning-objective-label">Learning Objectives</div>
                        <p>By the end of this resource, you will be able to:</p>
                        <ul>
                            <li>Explain how <span class="highlight-cyan">binary search</span> works and why it requires sorted data</li>
                            <li>Trace through a binary search algorithm step-by-step</li>
                            <li>Explain how <span class="highlight-purple">merge sort</span> uses divide and conquer</li>
                            <li>Trace through a merge sort algorithm showing splits and merges</li>
                            <li>Compare the <span class="highlight">efficiency</span> of different search and sort algorithms</li>
                        </ul>
                    </div>

                    <div class="connect-box">
                        <div class="connect-box-header">
                            üîó Connect to What You Know
                        </div>
                        <p>You've already learned what algorithms are ‚Äî step-by-step instructions to solve a problem. Now we're going deeper: not just <em>any</em> algorithm, but algorithms that solve two of computing's most fundamental problems: <strong>finding things</strong> and <strong>putting things in order</strong>.</p>
                    </div>

                    <p>These aren't just exam topics. Every time you search for a song on Spotify, find a contact in your phone, or sort your photos by date ‚Äî you're using these algorithms. Understanding them helps you understand how computers think.</p>

                    <h3>What's Covered</h3>
                    <p><span class="highlight-cyan">Search algorithms:</span> Linear search (quick review) and <strong>Binary Search</strong> (main focus)</p>
                    <p><span class="highlight-purple">Sort algorithms:</span> Bubble sort (quick review) and <strong>Merge Sort</strong> (main focus)</p>
                    <p><span class="highlight">Efficiency:</span> Why some algorithms are dramatically faster than others</p>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Overview</h4>
                    <ul>
                        <li>Search algorithms find items in a data set</li>
                        <li>Sort algorithms arrange items into order</li>
                        <li>This topic focuses on: Binary Search and Merge Sort</li>
                        <li>Understanding efficiency is key to choosing the right algorithm</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" disabled>‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 2: Why Efficiency Matters -->
            <section id="section-2">
                <div class="card">
                    <h2>‚ö° Why Efficiency Matters</h2>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î Think About It
                        </div>
                        <p>Imagine you need to find a specific word in a dictionary. Would you start at page 1 and check every single word? Or would you use a smarter approach?</p>
                    </div>

                    <p>When we have a small amount of data (say, 10 items), it doesn't really matter which algorithm we use. Even a "slow" algorithm will finish almost instantly.</p>

                    <p>But what happens when we scale up?</p>

                    <div class="example-box">
                        <div class="example-box-header">
                            <span class="example-badge">Example</span>
                            <span class="example-title">Searching 1 Billion Items</span>
                        </div>
                        <p style="color: var(--text-primary); margin-bottom: 12px;">Imagine searching through 1,000,000,000 items:</p>
                        <p style="color: var(--text-primary); margin-bottom: 8px;"><span class="highlight-magenta">Linear search</span> (checking each item): Up to <strong>1 billion comparisons</strong></p>
                        <p style="color: var(--text-primary); margin: 0;"><span class="highlight-green">Binary search</span>: Maximum <strong>30 comparisons</strong></p>
                    </div>

                    <p>That's not a typo. Binary search can find any item in a billion-item sorted list in at most 30 steps. This is the power of understanding algorithm efficiency.</p>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Concept</span>
                            <span class="key-term-word">Algorithm Efficiency</span>
                        </div>
                        <p>A measure of how an algorithm's performance (time or space) changes as the input size grows. More efficient algorithms can handle larger data sets without slowing down dramatically.</p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Why Efficiency Matters</h4>
                    <ul>
                        <li>Small data sets: algorithm choice doesn't matter much</li>
                        <li>Large data sets: efficiency becomes critical</li>
                        <li>Example: searching 1 billion items
                            <ul>
                                <li>Linear search: up to 1 billion comparisons</li>
                                <li>Binary search: maximum 30 comparisons</li>
                            </ul>
                        </li>
                        <li>Efficiency = how performance changes as input size grows</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 3: Linear Search Review -->
            <section id="section-3">
                <div class="card">
                    <h2>üîç Linear Search (Quick Review)</h2>

                    <p>Before we dive into binary search, let's quickly review the simpler approach: <span class="highlight-cyan">linear search</span>.</p>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Term</span>
                            <span class="key-term-word">Linear Search</span>
                        </div>
                        <p>An algorithm that finds an item by checking each element in sequence, from start to end, until the target is found or the end is reached.</p>
                    </div>

                    <h3>How It Works</h3>
                    <p>Linear search is like looking for your friend in a queue by checking each person one by one, starting from the front:</p>
                    <ol style="color: var(--text-secondary); padding-left: 24px; margin-bottom: 16px;">
                        <li>Start at the first item</li>
                        <li>Compare it to what you're looking for</li>
                        <li>If it matches, you've found it ‚Äî stop</li>
                        <li>If not, move to the next item</li>
                        <li>Repeat until found or you've checked everything</li>
                    </ol>

                    <h3>Interactive Demo</h3>
                    <p>Watch linear search find the number <span class="highlight">42</span> in this unsorted list:</p>

                    <div class="array-container" id="linearArray">
                        <!-- Generated by JS -->
                    </div>

                    <div class="explanation-panel" id="linearExplanation">
                        <p>Click "Start Search" to watch linear search in action.</p>
                    </div>

                    <div class="controls">
                        <button class="control-btn primary" id="linearStartBtn" onclick="startLinearSearch()">Start Search</button>
                        <button class="control-btn secondary" onclick="resetLinearSearch()">Reset</button>
                    </div>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î Key Insight
                        </div>
                        <p><strong>Advantage:</strong> Works on ANY list ‚Äî sorted or unsorted.</p>
                        <p style="margin-top: 8px;"><strong>Disadvantage:</strong> If the item is at the end (or not there at all), you check everything. For a list of 1000 items, that's potentially 1000 comparisons.</p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Linear Search</h4>
                    <ul>
                        <li>Checks each element in order from start to end</li>
                        <li>Stops when target is found or end is reached</li>
                        <li>Works on sorted AND unsorted data</li>
                        <li>Worst case: checks every item (n comparisons for n items)</li>
                        <li>Best case: target is first item (1 comparison)</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 4: Binary Search Concept -->
            <section id="section-4">
                <div class="card">
                    <h2>üéØ Binary Search: The Concept</h2>

                    <div class="connect-box">
                        <div class="connect-box-header">
                            üîó Connect to What You Know
                        </div>
                        <p>Remember how you'd actually find a word in a physical dictionary? You wouldn't start at page 1. You'd open it roughly in the middle, see if your word comes before or after that page, then repeat. That's binary search.</p>
                    </div>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Term</span>
                            <span class="key-term-word">Binary Search</span>
                        </div>
                        <p>An efficient search algorithm that finds an item in a <strong>sorted</strong> list by repeatedly dividing the search area in half. Each comparison eliminates half of the remaining possibilities.</p>
                    </div>

                    <div class="warning-box">
                        <div class="warning-box-header">
                            ‚ö†Ô∏è Common Misconception
                        </div>
                        <p><strong>Binary search ONLY works on sorted data.</strong> This is the most common mistake in exams. If the data isn't sorted, binary search will give wrong results. Always check!</p>
                    </div>

                    <h3>The Algorithm</h3>
                    <ol style="color: var(--text-secondary); padding-left: 24px; margin-bottom: 16px;">
                        <li>Find the <span class="highlight">middle</span> item of the current search area</li>
                        <li>Compare it to the target:
                            <ul style="margin-top: 8px;">
                                <li>If it <strong>matches</strong> ‚Üí Found it! Stop.</li>
                                <li>If target is <strong>smaller</strong> ‚Üí Search the left half</li>
                                <li>If target is <strong>larger</strong> ‚Üí Search the right half</li>
                            </ul>
                        </li>
                        <li>Repeat with the new (smaller) search area</li>
                        <li>If the search area becomes empty ‚Üí Target isn't in the list</li>
                    </ol>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î Why "Binary"?
                        </div>
                        <p>"Binary" means two. At each step, we make a <strong>binary decision</strong> (left or right) that eliminates half the remaining items. This is why it's so fast ‚Äî the search area halves with every comparison.</p>
                    </div>

                    <h3>Finding the Middle</h3>
                    <p>To find the middle index, we use this formula:</p>
                    <div class="code-block">
                        <pre><span class="code-function">midpoint</span> = (<span class="code-function">low</span> + <span class="code-function">high</span>) // <span class="code-number">2</span></pre>
                    </div>
                    <p>Where <code>low</code> is the first index of our search area and <code>high</code> is the last index. The <code>//</code> means integer division (round down).</p>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Binary Search Concept</h4>
                    <ul>
                        <li><strong>Requirement:</strong> Data MUST be sorted</li>
                        <li>Uses "divide and conquer" ‚Äî halves search area each step</li>
                        <li>Compare middle item to target:
                            <ul>
                                <li>Match ‚Üí Found</li>
                                <li>Target smaller ‚Üí Search left half</li>
                                <li>Target larger ‚Üí Search right half</li>
                            </ul>
                        </li>
                        <li>Midpoint formula: (low + high) // 2</li>
                        <li>"Binary" = two choices at each step</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 5: Binary Search Interactive -->
            <section id="section-5">
                <div class="card">
                    <h2>üî¨ Binary Search: Step-by-Step</h2>

                    <p>Let's trace through binary search finding <span class="highlight">23</span> in this sorted list:</p>

                    <div class="array-container" id="binaryArray">
                        <!-- Generated by JS -->
                    </div>

                    <div class="step-indicator">
                        <span class="step-label">Low:</span>
                        <span class="step-value" id="binaryLow">0</span>
                        <span class="step-label" style="margin-left: 20px;">High:</span>
                        <span class="step-value" id="binaryHigh">9</span>
                        <span class="step-label" style="margin-left: 20px;">Mid:</span>
                        <span class="step-value" id="binaryMid">-</span>
                    </div>

                    <div class="explanation-panel" id="binaryExplanation">
                        <p>Click "Next Step" to trace through the binary search algorithm. Watch how half the list is eliminated with each comparison.</p>
                    </div>

                    <div class="controls">
                        <button class="control-btn primary" id="binaryStepBtn" onclick="binarySearchStep()">Next Step</button>
                        <button class="control-btn secondary" onclick="resetBinarySearch()">Reset</button>
                    </div>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î Count the Steps
                        </div>
                        <p>As you step through, count how many comparisons binary search makes. Then think: how many would linear search need to find the same number?</p>
                    </div>
                </div>

                <div class="card">
                    <h3>Try Different Values</h3>
                    <p>Enter a number to search for (pick from the list above):</p>
                    
                    <div class="input-group">
                        <input type="number" class="input-field" id="binaryTargetInput" placeholder="e.g. 42" min="1" max="99">
                        <button class="control-btn primary" onclick="setBinaryTarget()">Search</button>
                    </div>

                    <div class="feedback hint" id="binaryTargetFeedback" style="display: none;"></div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Binary Search Trace</h4>
                    <ul>
                        <li>Track three pointers: low, high, mid</li>
                        <li>Calculate mid = (low + high) // 2</li>
                        <li>After each comparison:
                            <ul>
                                <li>Target > mid value: low = mid + 1</li>
                                <li>Target < mid value: high = mid - 1</li>
                            </ul>
                        </li>
                        <li>Stop when: found OR low > high (not found)</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 6: Search Algorithm Comparison -->
            <section id="section-6">
                <div class="card">
                    <h2>‚öñÔ∏è Comparing Search Algorithms</h2>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Criteria</th>
                                <th>Linear Search</th>
                                <th>Binary Search</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Data requirement</strong></td>
                                <td>Any order</td>
                                <td>Must be sorted</td>
                            </tr>
                            <tr>
                                <td><strong>Best case</strong></td>
                                <td>1 comparison</td>
                                <td>1 comparison</td>
                            </tr>
                            <tr>
                                <td><strong>Worst case (n items)</strong></td>
                                <td>n comparisons</td>
                                <td>log‚ÇÇ(n) comparisons</td>
                            </tr>
                            <tr>
                                <td><strong>1,000 items worst case</strong></td>
                                <td>1,000 comparisons</td>
                                <td>10 comparisons</td>
                            </tr>
                            <tr>
                                <td><strong>1,000,000 items worst case</strong></td>
                                <td>1,000,000 comparisons</td>
                                <td>20 comparisons</td>
                            </tr>
                            <tr>
                                <td><strong>When to use</strong></td>
                                <td>Small or unsorted lists</td>
                                <td>Large sorted lists</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Exam Tip</span>
                            <span class="key-term-word">log‚ÇÇ(n)</span>
                        </div>
                        <p>Binary search's worst case is log‚ÇÇ(n), which means "how many times can you halve n before reaching 1?" For 1000 items: 1000 ‚Üí 500 ‚Üí 250 ‚Üí 125 ‚Üí 62 ‚Üí 31 ‚Üí 15 ‚Üí 7 ‚Üí 3 ‚Üí 1 = about 10 steps.</p>
                    </div>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î When Would You Choose Linear Search?
                        </div>
                        <p>Even though binary search is faster, there are situations where linear search is the better choice:</p>
                        <ul style="margin-top: 8px; padding-left: 20px; color: var(--text-primary);">
                            <li>Data is unsorted and sorting it would take too long</li>
                            <li>You're only searching once (sorting + binary search > just linear search)</li>
                            <li>The list is very small</li>
                            <li>Data changes frequently (maintaining sorted order is costly)</li>
                        </ul>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Search Algorithm Comparison</h4>
                    <p><strong>Linear Search:</strong></p>
                    <ul>
                        <li>Works on sorted or unsorted data</li>
                        <li>Worst case: n comparisons</li>
                        <li>Use for: small lists, unsorted data, one-time searches</li>
                    </ul>
                    <p style="margin-top: 12px;"><strong>Binary Search:</strong></p>
                    <ul>
                        <li>Requires sorted data</li>
                        <li>Worst case: log‚ÇÇ(n) comparisons</li>
                        <li>Use for: large sorted lists, repeated searches</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 7: Bubble Sort Review -->
            <section id="section-7">
                <div class="card">
                    <h2>ü´ß Bubble Sort (Quick Review)</h2>

                    <p>Before we explore merge sort, let's quickly review <span class="highlight-cyan">bubble sort</span> ‚Äî a simpler but less efficient sorting algorithm.</p>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Term</span>
                            <span class="key-term-word">Bubble Sort</span>
                        </div>
                        <p>A sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order. Larger values "bubble up" to the end.</p>
                    </div>

                    <h3>How It Works</h3>
                    <ol style="color: var(--text-secondary); padding-left: 24px; margin-bottom: 16px;">
                        <li>Compare the first two elements ‚Äî swap if needed</li>
                        <li>Move to the next pair and compare ‚Äî swap if needed</li>
                        <li>Continue until you reach the end (one "pass")</li>
                        <li>Repeat passes until no swaps are made</li>
                    </ol>

                    <div class="example-box">
                        <div class="example-box-header">
                            <span class="example-badge">Example</span>
                            <span class="example-title">One Pass of Bubble Sort</span>
                        </div>
                        <p style="color: var(--text-primary); font-family: 'JetBrains Mono', monospace; margin-bottom: 8px;">[5, 3, 8, 1] ‚Üí Compare 5,3 ‚Üí Swap ‚Üí [3, 5, 8, 1]</p>
                        <p style="color: var(--text-primary); font-family: 'JetBrains Mono', monospace; margin-bottom: 8px;">[3, 5, 8, 1] ‚Üí Compare 5,8 ‚Üí No swap</p>
                        <p style="color: var(--text-primary); font-family: 'JetBrains Mono', monospace; margin: 0;">[3, 5, 8, 1] ‚Üí Compare 8,1 ‚Üí Swap ‚Üí [3, 5, 1, 8]</p>
                        <p style="color: var(--text-secondary); margin-top: 12px;">After one pass, the largest value (8) has "bubbled" to the end.</p>
                    </div>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î The Problem with Bubble Sort
                        </div>
                        <p>Bubble sort is easy to understand and code, but it's slow. For n items, it might need up to n¬≤ comparisons in the worst case. For 1000 items, that's potentially 1,000,000 comparisons!</p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Bubble Sort</h4>
                    <ul>
                        <li>Compares adjacent pairs, swaps if in wrong order</li>
                        <li>Each pass moves largest unsorted item to its final position</li>
                        <li>Repeats until a complete pass with no swaps</li>
                        <li>Worst case: n¬≤ comparisons (very slow for large lists)</li>
                        <li>Advantage: Simple to understand and implement</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 8: Merge Sort Concept -->
            <section id="section-8">
                <div class="card">
                    <h2>üîÄ Merge Sort: The Concept</h2>

                    <div class="connect-box">
                        <div class="connect-box-header">
                            üîó Connect to What You Know
                        </div>
                        <p>Imagine sorting a deck of cards. Instead of comparing cards one by one, you could split the deck in half, sort each half separately, then merge them back together. If each half is still too big? Split those too. Keep splitting until you have single cards ‚Äî which are automatically "sorted"!</p>
                    </div>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Term</span>
                            <span class="key-term-word">Merge Sort</span>
                        </div>
                        <p>A sorting algorithm that uses <strong>divide and conquer</strong>: split the list in half repeatedly until you have single items, then merge them back together in sorted order.</p>
                    </div>

                    <h3>The Two Phases</h3>
                    
                    <p><span class="highlight-magenta">Phase 1: DIVIDE</span></p>
                    <ul style="color: var(--text-secondary); padding-left: 24px; margin-bottom: 16px;">
                        <li>Split the list into two halves</li>
                        <li>Keep splitting until each sublist has just one item</li>
                        <li>A single item is already sorted (nothing to compare it to!)</li>
                    </ul>

                    <p><span class="highlight-green">Phase 2: MERGE</span></p>
                    <ul style="color: var(--text-secondary); padding-left: 24px; margin-bottom: 16px;">
                        <li>Take two sorted sublists</li>
                        <li>Compare their first elements, take the smaller one</li>
                        <li>Repeat until both sublists are empty</li>
                        <li>Result: one larger sorted list</li>
                    </ul>

                    <div class="think-box">
                        <div class="think-box-header">
                            ü§î Why Does This Work?
                        </div>
                        <p>The clever insight is that merging two <em>sorted</em> lists is easy and fast. You only ever compare the front items of each list. Since merge sort always merges sorted sublists (starting from single items, which are trivially sorted), the merge step is efficient.</p>
                    </div>

                    <div class="key-term">
                        <div class="key-term-header">
                            <span class="key-term-badge">Key Concept</span>
                            <span class="key-term-word">Divide and Conquer</span>
                        </div>
                        <p>An algorithm design strategy that breaks a problem into smaller subproblems, solves each subproblem, then combines the solutions. Both binary search and merge sort use this approach.</p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Merge Sort Concept</h4>
                    <ul>
                        <li>Uses divide and conquer strategy</li>
                        <li><strong>Divide phase:</strong> Split list in half until single items</li>
                        <li><strong>Merge phase:</strong> Combine sorted sublists into larger sorted lists</li>
                        <li>Single items are automatically sorted</li>
                        <li>Merging sorted lists is efficient (only compare front items)</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 9: Merge Sort Interactive -->
            <section id="section-9">
                <div class="card">
                    <h2>üî¨ Merge Sort: Step-by-Step</h2>

                    <p>Let's trace through merge sort on this list: <span class="highlight">[38, 27, 43, 3, 9, 82, 10]</span></p>

                    <div id="mergeSortVisualization">
                        <!-- Phase indicator -->
                        <div class="step-indicator">
                            <span class="step-label">Phase:</span>
                            <span class="step-value" id="mergePhase">Ready</span>
                            <span class="step-label" style="margin-left: 20px;">Step:</span>
                            <span class="step-value" id="mergeStep">0</span>
                        </div>

                        <div id="mergeLevels">
                            <!-- Generated by JS -->
                        </div>
                    </div>

                    <div class="explanation-panel" id="mergeExplanation">
                        <p>Click "Next Step" to see merge sort split the list, then merge it back together in sorted order.</p>
                    </div>

                    <div class="controls">
                        <button class="control-btn primary" id="mergeStepBtn" onclick="mergeSortStep()">Next Step</button>
                        <button class="control-btn secondary" onclick="resetMergeSort()">Reset</button>
                    </div>

                    <div class="warning-box">
                        <div class="warning-box-header">
                            ‚ö†Ô∏è Exam Tip: Showing Your Working
                        </div>
                        <p>In the exam, you'll often be asked to "show the steps of merge sort". Make sure you clearly show:</p>
                        <ul style="margin-top: 8px; padding-left: 20px; color: var(--text-primary);">
                            <li>Each split until you reach single items</li>
                            <li>Each merge, showing how items are compared and combined</li>
                            <li>The final sorted list</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3>The Merge Process in Detail</h3>
                    <p>The merge step is where the actual sorting happens. Here's how to merge [27, 38] with [3, 43]:</p>

                    <div class="example-box">
                        <div class="example-box-header">
                            <span class="example-badge">Trace</span>
                            <span class="example-title">Merging Two Sorted Lists</span>
                        </div>
                        <p style="color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;">
                            Left: [27, 38]  Right: [3, 43]  Result: []<br><br>
                            Compare 27 and 3 ‚Üí 3 is smaller ‚Üí Result: [3]<br>
                            Left: [27, 38]  Right: [43]<br><br>
                            Compare 27 and 43 ‚Üí 27 is smaller ‚Üí Result: [3, 27]<br>
                            Left: [38]  Right: [43]<br><br>
                            Compare 38 and 43 ‚Üí 38 is smaller ‚Üí Result: [3, 27, 38]<br>
                            Left: []  Right: [43]<br><br>
                            Left is empty ‚Üí Add remaining: Result: [3, 27, 38, 43] ‚úì
                        </p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Notes for This Section
                    </div>
                    <h4>Merge Sort Trace</h4>
                    <p><strong>Split phase:</strong></p>
                    <ul>
                        <li>[38,27,43,3,9,82,10]</li>
                        <li>[38,27,43,3] and [9,82,10]</li>
                        <li>[38,27] [43,3] [9,82] [10]</li>
                        <li>[38] [27] [43] [3] [9] [82] [10]</li>
                    </ul>
                    <p style="margin-top: 12px;"><strong>Merge phase:</strong></p>
                    <ul>
                        <li>Merge pairs: [27,38] [3,43] [9,82] [10]</li>
                        <li>Merge again: [3,27,38,43] [9,10,82]</li>
                        <li>Final merge: [3,9,10,27,38,43,82]</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" onclick="nextSection()">Next ‚Üí</button>
                </div>
            </section>

            <!-- Section 10: Quiz -->
            <section id="section-10">
                <div class="card">
                    <h2>‚úÖ Check Your Understanding</h2>

                    <div class="learning-objective">
                        <div class="learning-objective-label">Checkpoint Quiz</div>
                        <p>Test your knowledge of binary search and merge sort. Take your time and think carefully about each question.</p>
                    </div>

                    <!-- Question 1 -->
                    <div class="question-box" id="q1">
                        <p><strong>Question 1:</strong> What is the essential requirement for binary search to work correctly?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(1, this, false)">The list must contain numbers only</button>
                            <button class="option-btn" onclick="checkAnswer(1, this, true)">The list must be sorted</button>
                            <button class="option-btn" onclick="checkAnswer(1, this, false)">The list must have an odd number of items</button>
                            <button class="option-btn" onclick="checkAnswer(1, this, false)">The list must not contain duplicates</button>
                        </div>
                        <div class="feedback" id="feedback1"></div>
                    </div>

                    <!-- Question 2 -->
                    <div class="question-box" id="q2">
                        <p><strong>Question 2:</strong> In binary search, if you're searching for 25 and the middle value is 30, what happens next?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(2, this, true)">Search the left half (values less than 30)</button>
                            <button class="option-btn" onclick="checkAnswer(2, this, false)">Search the right half (values greater than 30)</button>
                            <button class="option-btn" onclick="checkAnswer(2, this, false)">Start again from the beginning</button>
                            <button class="option-btn" onclick="checkAnswer(2, this, false)">The search ends unsuccessfully</button>
                        </div>
                        <div class="feedback" id="feedback2"></div>
                    </div>

                    <!-- Question 3 -->
                    <div class="question-box" id="q3">
                        <p><strong>Question 3:</strong> What is the maximum number of comparisons needed to find an item in a sorted list of 1024 items using binary search?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(3, this, false)">512</button>
                            <button class="option-btn" onclick="checkAnswer(3, this, false)">100</button>
                            <button class="option-btn" onclick="checkAnswer(3, this, true)">10</button>
                            <button class="option-btn" onclick="checkAnswer(3, this, false)">1024</button>
                        </div>
                        <div class="feedback" id="feedback3"></div>
                    </div>

                    <!-- Question 4 -->
                    <div class="question-box" id="q4">
                        <p><strong>Question 4:</strong> In merge sort, why are single items considered "sorted"?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(4, this, false)">Because they've already been compared</button>
                            <button class="option-btn" onclick="checkAnswer(4, this, true)">Because there's nothing to compare them with</button>
                            <button class="option-btn" onclick="checkAnswer(4, this, false)">Because merge sort pre-sorts them</button>
                            <button class="option-btn" onclick="checkAnswer(4, this, false)">Because they're always the smallest values</button>
                        </div>
                        <div class="feedback" id="feedback4"></div>
                    </div>

                    <!-- Question 5 -->
                    <div class="question-box" id="q5">
                        <p><strong>Question 5:</strong> When merging [2, 5] and [3, 4], which element is placed first in the result?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(5, this, true)">2 (compare front elements, 2 < 3)</button>
                            <button class="option-btn" onclick="checkAnswer(5, this, false)">3 (from the second list)</button>
                            <button class="option-btn" onclick="checkAnswer(5, this, false)">5 (largest from first list)</button>
                            <button class="option-btn" onclick="checkAnswer(5, this, false)">4 (largest from second list)</button>
                        </div>
                        <div class="feedback" id="feedback5"></div>
                    </div>

                    <!-- Question 6 -->
                    <div class="question-box" id="q6">
                        <p><strong>Question 6:</strong> Which statement about algorithm efficiency is correct?</p>
                        <div class="options">
                            <button class="option-btn" onclick="checkAnswer(6, this, false)">Linear search is always faster than binary search</button>
                            <button class="option-btn" onclick="checkAnswer(6, this, false)">Bubble sort is more efficient than merge sort for large lists</button>
                            <button class="option-btn" onclick="checkAnswer(6, this, true)">Binary search has O(log n) efficiency, meaning it halves the search space each step</button>
                            <button class="option-btn" onclick="checkAnswer(6, this, false)">Merge sort doesn't need any extra memory</button>
                        </div>
                        <div class="feedback" id="feedback6"></div>
                    </div>

                    <div id="quizResult" style="display: none; margin-top: 20px; padding: 20px; background: var(--bg-card); border-radius: 12px; text-align: center;">
                        <h3 id="quizScore" style="color: var(--accent-green);"></h3>
                        <p id="quizMessage" style="color: var(--text-secondary);"></p>
                    </div>
                </div>

                <div class="notes-summary">
                    <div class="notes-summary-header">
                        üìù Complete Summary for Your Notes
                    </div>
                    
                    <h4>Binary Search</h4>
                    <ul>
                        <li><strong>Requirement:</strong> Data must be sorted</li>
                        <li><strong>Method:</strong> Check middle, eliminate half each time</li>
                        <li><strong>Midpoint:</strong> (low + high) // 2</li>
                        <li><strong>Efficiency:</strong> O(log n) ‚Äî very fast for large lists</li>
                        <li><strong>1000 items:</strong> max 10 comparisons</li>
                    </ul>

                    <h4>Merge Sort</h4>
                    <ul>
                        <li><strong>Strategy:</strong> Divide and conquer</li>
                        <li><strong>Split:</strong> Divide until single items</li>
                        <li><strong>Merge:</strong> Compare front items, build sorted list</li>
                        <li><strong>Why it works:</strong> Merging sorted lists is efficient</li>
                        <li><strong>Efficiency:</strong> O(n log n) ‚Äî faster than bubble sort's O(n¬≤)</li>
                    </ul>

                    <h4>Comparison Table</h4>
                    <ul>
                        <li>Linear search: O(n) ‚Äî unsorted OK</li>
                        <li>Binary search: O(log n) ‚Äî must be sorted</li>
                        <li>Bubble sort: O(n¬≤) ‚Äî simple but slow</li>
                        <li>Merge sort: O(n log n) ‚Äî fast but uses extra memory</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn prev" onclick="prevSection()">‚Üê Previous</button>
                    <button class="nav-btn next" disabled style="background: var(--accent-green);">Complete! üéâ</button>
                </div>
            </section>
        </main>
    </div>

    <script>
        // ============ Navigation ============
        const totalSections = 10;
        let currentSection = 1;

        function updateProgress() {
            const progressBar = document.getElementById('progressBar');
            progressBar.innerHTML = '';
            
            for (let i = 1; i <= totalSections; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                if (i === currentSection) dot.classList.add('active');
                if (i < currentSection) dot.classList.add('completed');
                dot.onclick = () => goToSection(i);
                progressBar.appendChild(dot);
            }
            
            document.getElementById('progressLabel').textContent = `Section ${currentSection} of ${totalSections}`;
        }

        function goToSection(num) {
            document.getElementById(`section-${currentSection}`).classList.remove('active');
            currentSection = num;
            document.getElementById(`section-${currentSection}`).classList.add('active');
            updateProgress();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function nextSection() {
            if (currentSection < totalSections) {
                goToSection(currentSection + 1);
            }
        }

        function prevSection() {
            if (currentSection > 1) {
                goToSection(currentSection - 1);
            }
        }

        // ============ Linear Search ============
        const linearData = [17, 42, 8, 56, 23, 91, 4, 67, 33, 12];
        const linearTarget = 42;
        let linearStep = 0;
        let linearSearching = false;

        function renderLinearArray() {
            const container = document.getElementById('linearArray');
            container.innerHTML = '';
            
            linearData.forEach((val, idx) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'array-wrapper';
                
                const item = document.createElement('div');
                item.className = 'array-item';
                item.id = `linear-${idx}`;
                item.textContent = val;
                
                const index = document.createElement('div');
                index.className = 'array-index';
                index.textContent = idx;
                
                wrapper.appendChild(item);
                wrapper.appendChild(index);
                container.appendChild(wrapper);
            });
        }

        function startLinearSearch() {
            if (linearSearching) return;
            linearSearching = true;
            document.getElementById('linearStartBtn').disabled = true;
            linearStep = 0;
            
            const interval = setInterval(() => {
                // Clear previous highlights
                document.querySelectorAll('#linearArray .array-item').forEach(el => {
                    el.classList.remove('highlight-search', 'found', 'eliminated');
                });
                
                if (linearStep < linearData.length) {
                    const item = document.getElementById(`linear-${linearStep}`);
                    
                    if (linearData[linearStep] === linearTarget) {
                        item.classList.add('found');
                        document.getElementById('linearExplanation').innerHTML = 
                            `<p><span class="highlight-green">Found it!</span> The value ${linearTarget} was at index ${linearStep}. Linear search checked ${linearStep + 1} item(s).</p>`;
                        clearInterval(interval);
                        linearSearching = false;
                        document.getElementById('linearStartBtn').disabled = false;
                    } else {
                        item.classList.add('highlight-search');
                        // Mark previous as eliminated
                        for (let i = 0; i < linearStep; i++) {
                            document.getElementById(`linear-${i}`).classList.add('eliminated');
                        }
                        document.getElementById('linearExplanation').innerHTML = 
                            `<p>Checking index ${linearStep}: Is ${linearData[linearStep]} equal to ${linearTarget}? <span class="highlight-magenta">No.</span> Move to next item.</p>`;
                        linearStep++;
                    }
                } else {
                    document.getElementById('linearExplanation').innerHTML = 
                        `<p><span class="highlight-magenta">Not found.</span> Checked all ${linearData.length} items.</p>`;
                    clearInterval(interval);
                    linearSearching = false;
                    document.getElementById('linearStartBtn').disabled = false;
                }
            }, 800);
        }

        function resetLinearSearch() {
            linearStep = 0;
            linearSearching = false;
            document.getElementById('linearStartBtn').disabled = false;
            renderLinearArray();
            document.getElementById('linearExplanation').innerHTML = 
                '<p>Click "Start Search" to watch linear search in action.</p>';
        }

        // ============ Binary Search ============
        const binaryData = [3, 7, 12, 19, 23, 31, 42, 56, 78, 91];
        let binaryTarget = 23;
        let binaryLow = 0;
        let binaryHigh = binaryData.length - 1;
        let binaryMid = -1;
        let binaryFound = false;
        let binaryStep = 0;

        function renderBinaryArray() {
            const container = document.getElementById('binaryArray');
            container.innerHTML = '';
            
            binaryData.forEach((val, idx) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'array-wrapper';
                
                const item = document.createElement('div');
                item.className = 'array-item';
                item.id = `binary-${idx}`;
                item.textContent = val;
                
                const index = document.createElement('div');
                index.className = 'array-index';
                index.textContent = idx;
                
                wrapper.appendChild(item);
                wrapper.appendChild(index);
                container.appendChild(wrapper);
            });
            
            updateBinaryDisplay();
        }

        function updateBinaryDisplay() {
            document.getElementById('binaryLow').textContent = binaryLow;
            document.getElementById('binaryHigh').textContent = binaryHigh;
            document.getElementById('binaryMid').textContent = binaryMid >= 0 ? binaryMid : '-';
            
            // Update visual
            document.querySelectorAll('#binaryArray .array-item').forEach((el, idx) => {
                el.classList.remove('highlight-search', 'found', 'eliminated', 'comparing');
                
                if (binaryFound && idx === binaryMid) {
                    el.classList.add('found');
                } else if (idx < binaryLow || idx > binaryHigh) {
                    el.classList.add('eliminated');
                } else if (idx === binaryMid) {
                    el.classList.add('comparing');
                }
            });
        }

        function binarySearchStep() {
            if (binaryFound || binaryLow > binaryHigh) {
                return;
            }
            
            binaryStep++;
            binaryMid = Math.floor((binaryLow + binaryHigh) / 2);
            
            const explanation = document.getElementById('binaryExplanation');
            
            if (binaryData[binaryMid] === binaryTarget) {
                binaryFound = true;
                explanation.innerHTML = `<p><strong>Step ${binaryStep}:</strong> Mid = (${binaryLow} + ${binaryHigh}) / 2 = ${binaryMid}. Value at index ${binaryMid} is ${binaryData[binaryMid]}. <span class="highlight-green">Found it!</span> Binary search took ${binaryStep} comparison(s).</p>`;
                document.getElementById('binaryStepBtn').disabled = true;
            } else if (binaryData[binaryMid] < binaryTarget) {
                explanation.innerHTML = `<p><strong>Step ${binaryStep}:</strong> Mid = (${binaryLow} + ${binaryHigh}) / 2 = ${binaryMid}. Value at index ${binaryMid} is ${binaryData[binaryMid]}. Target ${binaryTarget} is <span class="highlight-cyan">greater</span>, so search right half. Set low = ${binaryMid + 1}.</p>`;
                binaryLow = binaryMid + 1;
            } else {
                explanation.innerHTML = `<p><strong>Step ${binaryStep}:</strong> Mid = (${binaryLow} + ${binaryHigh}) / 2 = ${binaryMid}. Value at index ${binaryMid} is ${binaryData[binaryMid]}. Target ${binaryTarget} is <span class="highlight-cyan">smaller</span>, so search left half. Set high = ${binaryMid - 1}.</p>`;
                binaryHigh = binaryMid - 1;
            }
            
            if (!binaryFound && binaryLow > binaryHigh) {
                explanation.innerHTML = `<p><strong>Step ${binaryStep}:</strong> Low (${binaryLow}) > High (${binaryHigh}). <span class="highlight-magenta">Target ${binaryTarget} not found.</span></p>`;
                document.getElementById('binaryStepBtn').disabled = true;
            }
            
            updateBinaryDisplay();
        }

        function resetBinarySearch() {
            binaryLow = 0;
            binaryHigh = binaryData.length - 1;
            binaryMid = -1;
            binaryFound = false;
            binaryStep = 0;
            document.getElementById('binaryStepBtn').disabled = false;
            document.getElementById('binaryExplanation').innerHTML = 
                '<p>Click "Next Step" to trace through the binary search algorithm. Watch how half the list is eliminated with each comparison.</p>';
            renderBinaryArray();
        }

        function setBinaryTarget() {
            const input = document.getElementById('binaryTargetInput');
            const feedback = document.getElementById('binaryTargetFeedback');
            const val = parseInt(input.value);
            
            if (isNaN(val)) {
                feedback.textContent = 'Please enter a number.';
                feedback.style.display = 'block';
                return;
            }
            
            if (!binaryData.includes(val)) {
                feedback.textContent = `${val} isn't in the list. Try: ${binaryData.join(', ')}`;
                feedback.className = 'feedback hint';
                feedback.style.display = 'block';
            } else {
                feedback.style.display = 'none';
            }
            
            binaryTarget = val;
            resetBinarySearch();
            document.getElementById('binaryExplanation').innerHTML = 
                `<p>Now searching for <span class="highlight">${binaryTarget}</span>. Click "Next Step" to begin.</p>`;
        }

        // ============ Merge Sort ============
        const mergeOriginal = [38, 27, 43, 3, 9, 82, 10];
        let mergeStepCount = 0;
        
        // Pre-calculated states for the visualization
        const mergeStates = [
            { phase: 'Start', levels: [[[38, 27, 43, 3, 9, 82, 10]]], explanation: 'Starting with unsorted list: [38, 27, 43, 3, 9, 82, 10]' },
            { phase: 'Split', levels: [[[38, 27, 43, 3], [9, 82, 10]]], explanation: 'Split into two halves: [38, 27, 43, 3] and [9, 82, 10]' },
            { phase: 'Split', levels: [[[38, 27], [43, 3], [9, 82], [10]]], explanation: 'Split again: [38, 27], [43, 3], [9, 82], [10]' },
            { phase: 'Split', levels: [[[38], [27], [43], [3], [9], [82], [10]]], explanation: 'Split to single items ‚Äî each is now "sorted"!' },
            { phase: 'Merge', levels: [[[27, 38], [3, 43], [9, 82], [10]]], explanation: 'Merge pairs: [38]&[27]‚Üí[27,38], [43]&[3]‚Üí[3,43], [9]&[82]‚Üí[9,82], [10] stays' },
            { phase: 'Merge', levels: [[[3, 27, 38, 43], [9, 10, 82]]], explanation: 'Merge again: [27,38]&[3,43]‚Üí[3,27,38,43], [9,82]&[10]‚Üí[9,10,82]' },
            { phase: 'Complete', levels: [[[3, 9, 10, 27, 38, 43, 82]]], explanation: 'Final merge: [3,27,38,43]&[9,10,82]‚Üí[3,9,10,27,38,43,82] ‚úì Sorted!' }
        ];

        function renderMergeSort() {
            const container = document.getElementById('mergeLevels');
            const state = mergeStates[mergeStepCount];
            
            document.getElementById('mergePhase').textContent = state.phase;
            document.getElementById('mergeStep').textContent = mergeStepCount;
            document.getElementById('mergeExplanation').innerHTML = `<p>${state.explanation}</p>`;
            
            container.innerHTML = '';
            
            state.levels.forEach(level => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'merge-level';
                
                level.forEach(group => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'merge-group';
                    if (state.phase === 'Merge' || state.phase === 'Complete') {
                        groupDiv.classList.add('active');
                    }
                    
                    group.forEach(val => {
                        const item = document.createElement('div');
                        item.className = 'merge-item';
                        item.textContent = val;
                        if (state.phase === 'Complete') {
                            item.style.borderColor = 'var(--accent-green)';
                            item.style.background = 'rgba(0, 255, 136, 0.15)';
                        }
                        groupDiv.appendChild(item);
                    });
                    
                    levelDiv.appendChild(groupDiv);
                });
                
                container.appendChild(levelDiv);
            });
        }

        function mergeSortStep() {
            if (mergeStepCount < mergeStates.length - 1) {
                mergeStepCount++;
                renderMergeSort();
                
                if (mergeStepCount === mergeStates.length - 1) {
                    document.getElementById('mergeStepBtn').disabled = true;
                }
            }
        }

        function resetMergeSort() {
            mergeStepCount = 0;
            document.getElementById('mergeStepBtn').disabled = false;
            renderMergeSort();
        }

        // ============ Quiz ============
        let answeredQuestions = new Set();
        let correctAnswers = 0;

        const feedbackMessages = {
            1: { correct: "Correct! Binary search requires sorted data because it relies on being able to eliminate half the items based on whether the target is greater or less than the middle value.", incorrect: "Not quite. Binary search specifically requires sorted data ‚Äî without it, the algorithm can't correctly determine which half to search." },
            2: { correct: "Correct! Since 25 < 30, the target must be in the left half (smaller values). We set high = mid - 1 and continue.", incorrect: "Think about it: if you're looking for 25 and the middle is 30, is 25 bigger or smaller? You want to search where smaller values are." },
            3: { correct: "Correct! log‚ÇÇ(1024) = 10. Each comparison halves the search space: 1024‚Üí512‚Üí256‚Üí128‚Üí64‚Üí32‚Üí16‚Üí8‚Üí4‚Üí2‚Üí1 = 10 steps.", incorrect: "Remember, binary search halves the search space each time. How many times can you halve 1024 before reaching 1?" },
            4: { correct: "Exactly! A single item has no other items to be out of order with. It's trivially sorted, which is what makes merge sort's recursive approach work.", incorrect: "Think about what 'sorted' means ‚Äî items in order. If there's only one item, can it be out of order?" },
            5: { correct: "Correct! When merging, we always compare the front elements of each list. 2 < 3, so 2 goes first.", incorrect: "In the merge step, we compare the front elements of each sorted list and take the smaller one." },
            6: { correct: "Correct! Binary search's O(log n) efficiency means it halves the search space with each comparison, making it very fast for large sorted lists.", incorrect: "Think about what each algorithm does. Binary search halves the data each step (log n), while linear search checks everything (n)." }
        };

        function checkAnswer(questionNum, button, isCorrect) {
            if (answeredQuestions.has(questionNum)) return;
            
            answeredQuestions.add(questionNum);
            
            const options = button.parentElement.querySelectorAll('.option-btn');
            options.forEach(opt => {
                opt.disabled = true;
                if (opt === button) {
                    opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
            });
            
            const feedback = document.getElementById(`feedback${questionNum}`);
            feedback.textContent = isCorrect ? feedbackMessages[questionNum].correct : feedbackMessages[questionNum].incorrect;
            feedback.className = `feedback show ${isCorrect ? 'success' : 'error'}`;
            
            if (isCorrect) correctAnswers++;
            
            if (answeredQuestions.size === 6) {
                showQuizResult();
            }
        }

        function showQuizResult() {
            const result = document.getElementById('quizResult');
            const score = document.getElementById('quizScore');
            const message = document.getElementById('quizMessage');
            
            result.style.display = 'block';
            score.textContent = `${correctAnswers}/6 Correct`;
            
            if (correctAnswers === 6) {
                score.style.color = 'var(--accent-green)';
                message.textContent = "Perfect! You've mastered search and sort algorithms. Ready for the exam! üéâ";
            } else if (correctAnswers >= 4) {
                score.style.color = 'var(--accent-cyan)';
                message.textContent = "Good work! Review the questions you missed using the notes.";
            } else {
                score.style.color = 'var(--accent-yellow)';
                message.textContent = "Keep practicing! Go back through the sections and try again.";
            }
        }

        // ============ Initialize ============
        document.addEventListener('DOMContentLoaded', function() {
            updateProgress();
            renderLinearArray();
            renderBinaryArray();
            renderMergeSort();
        });
    </script>
</body>
</html>
